// -----------------------------------------------------------------------------
//                                    ILGPU
//                     Copyright (c) 2016-2018 Marcel Koester
//                                www.ilgpu.net
//
// File: CodeGeneratorDriver.cs
//
// This file is part of ILGPU and is distributed under the University of
// Illinois Open Source License. See LICENSE.txt for details
// -----------------------------------------------------------------------------

//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:4.0.30319.42000
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

using ILGPU.IR.Values;
using System;
using System.Diagnostics.CodeAnalysis;
using System.Reflection;

namespace ILGPU.Frontend
{
    partial class CodeGenerator
    {
        [SuppressMessage("Microsoft.Maintainability", "CA1505:AvoidUnmaintainableCode")]
        [SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
        private bool TryGenerateCode(BasicBlock block, ILInstruction instruction)
        {
            switch (instruction.InstructionType)
            {
                case ILInstructionType.Nop:
                    MakeNop();
                    return true;
                case ILInstructionType.Break:
                    MakeTrap();
                    return true;

                case ILInstructionType.Ldarg:
                    LoadVariable(block, new VariableRef(instruction.GetArgumentAs<int>(), VariableRefType.Argument));
                    return true;
                case ILInstructionType.Ldarga:
                    LoadVariableAddress(block, new VariableRef(instruction.GetArgumentAs<int>(), VariableRefType.Argument));
                    return true;
                case ILInstructionType.Starg:
                    StoreVariable(block, new VariableRef(instruction.GetArgumentAs<int>(), VariableRefType.Argument));
                    return true;

                case ILInstructionType.Ldloc:
                    LoadVariable(block, new VariableRef(instruction.GetArgumentAs<int>(), VariableRefType.Local));
                    return true;
                case ILInstructionType.Ldloca:
                    LoadVariableAddress(block, new VariableRef(instruction.GetArgumentAs<int>(), VariableRefType.Local));
                    return true;
                case ILInstructionType.Stloc:
                    StoreVariable(block, new VariableRef(instruction.GetArgumentAs<int>(), VariableRefType.Local));
                    return true;

                case ILInstructionType.LdI4:
                    Load(block, instruction.GetArgumentAs<int>());
                    return true;
                case ILInstructionType.LdI8:
                    Load(block, instruction.GetArgumentAs<long>());
                    return true;
                case ILInstructionType.LdR4:
                    Load(block, instruction.GetArgumentAs<float>());
                    return true;
                case ILInstructionType.LdR8:
                    Load(block, instruction.GetArgumentAs<double>());
                    return true;
                case ILInstructionType.Ldstr:
                    LoadString(block, instruction.GetArgumentAs<string>());
                    return true;

                case ILInstructionType.Dup:
                    MakeDup(block);
                    return true;
                case ILInstructionType.Pop:
                    MakePop(block);
                    return true;
                case ILInstructionType.Ret:
                    MakeReturn();
                    return true;
                case ILInstructionType.Call:
                    MakeCall(block, instruction.GetArgumentAs<MethodBase>());
                    return true;
                case ILInstructionType.Callvirt:
                    MakeVirtualCall(block, instruction);
                    return true;
                case ILInstructionType.Calli:
                    MakeCalli(instruction.Argument);
                    return true;
                case ILInstructionType.Jmp:
                    MakeJump(instruction.GetArgumentAs<MethodBase>());
                    return true;

                case ILInstructionType.Box:
                    MakeBox(block);
                    return true;
                case ILInstructionType.Unbox:
                    MakeUnbox(block, instruction.GetArgumentAs<Type>());
                    return true;

                case ILInstructionType.Br:
                    MakeBranch();
                    return true;

                case ILInstructionType.Brfalse:
                    MakeBranchFalse(block);
                    return true;
                case ILInstructionType.Brtrue:
                    MakeBranchTrue(block);
                    return true;

                case ILInstructionType.Beq:
                    MakeBranch(block, CompareKind.Equal, instruction.Flags);
                    return true;
                case ILInstructionType.Bne:
                    MakeBranch(block, CompareKind.NotEqual, instruction.Flags);
                    return true;
                case ILInstructionType.Bge:
                    MakeBranch(block, CompareKind.GreaterEqual, instruction.Flags);
                    return true;
                case ILInstructionType.Bgt:
                    MakeBranch(block, CompareKind.GreaterThan, instruction.Flags);
                    return true;
                case ILInstructionType.Ble:
                    MakeBranch(block, CompareKind.LessEqual, instruction.Flags);
                    return true;
                case ILInstructionType.Blt:
                    MakeBranch(block, CompareKind.LessThan, instruction.Flags);
                    return true;

                case ILInstructionType.Switch:
                    MakeSwitch(block);
                    return true;

                case ILInstructionType.Add:
                    MakeArithmetic(block, BinaryArithmeticKind.Add, instruction);
                    return true;
                case ILInstructionType.Sub:
                    MakeArithmetic(block, BinaryArithmeticKind.Sub, instruction);
                    return true;
                case ILInstructionType.Mul:
                    MakeArithmetic(block, BinaryArithmeticKind.Mul, instruction);
                    return true;
                case ILInstructionType.Div:
                    MakeArithmetic(block, BinaryArithmeticKind.Div, instruction);
                    return true;
                case ILInstructionType.Rem:
                    MakeArithmetic(block, BinaryArithmeticKind.Rem, instruction);
                    return true;
                case ILInstructionType.And:
                    MakeArithmetic(block, BinaryArithmeticKind.And, instruction);
                    return true;
                case ILInstructionType.Or:
                    MakeArithmetic(block, BinaryArithmeticKind.Or, instruction);
                    return true;
                case ILInstructionType.Xor:
                    MakeArithmetic(block, BinaryArithmeticKind.Xor, instruction);
                    return true;
                case ILInstructionType.Shl:
                    MakeArithmetic(block, BinaryArithmeticKind.Shl, instruction);
                    return true;
                case ILInstructionType.Shr:
                    MakeArithmetic(block, BinaryArithmeticKind.Shr, instruction);
                    return true;
                case ILInstructionType.Neg:
                    MakeArithmetic(block, UnaryArithmeticKind.Neg);
                    return true;
                case ILInstructionType.Not:
                    MakeArithmetic(block, UnaryArithmeticKind.Not);
                    return true;

                case ILInstructionType.Conv:
                    MakeConvert(block, instruction.GetArgumentAs<Type>(), instruction.Flags);
                    return true;

                case ILInstructionType.Initobj:
                    MakeInitObject(block, instruction.GetArgumentAs<Type>());
                    return true;
                case ILInstructionType.Newobj:
                    MakeNewObject(block, instruction.GetArgumentAs<MethodBase>());
                    return true;
                case ILInstructionType.Isinst:
                    MakeIsInstance(block, instruction.GetArgumentAs<Type>());
                    return true;

                case ILInstructionType.Ldfld:
                    MakeLoadField(block, instruction.GetArgumentAs<FieldInfo>());
                    return true;
                case ILInstructionType.Ldsfld:
                    MakeLoadStaticField(block, instruction.GetArgumentAs<FieldInfo>());
                    return true;
                case ILInstructionType.Ldflda:
                    MakeLoadFieldAddress(block, instruction.GetArgumentAs<FieldInfo>());
                    return true;
                case ILInstructionType.Ldsflda:
                    MakeLoadStaticFieldAddress(instruction.GetArgumentAs<FieldInfo>());
                    return true;
                case ILInstructionType.Stfld:
                    MakeStoreField(block, instruction.GetArgumentAs<FieldInfo>());
                    return true;
                case ILInstructionType.Stsfld:
                    MakeStoreStaticField(block, instruction.GetArgumentAs<FieldInfo>());
                    return true;

                case ILInstructionType.Ceq:
                    MakeCompare(block, CompareKind.Equal, instruction.Flags);
                    return true;
                case ILInstructionType.Cgt:
                    MakeCompare(block, CompareKind.GreaterThan, instruction.Flags);
                    return true;
                case ILInstructionType.Clt:
                    MakeCompare(block, CompareKind.LessThan, instruction.Flags);
                    return true;

                case ILInstructionType.Ldobj:
                case ILInstructionType.Ldind:
                    MakeLoadObject(block, instruction.GetArgumentAs<Type>());
                    return true;
                case ILInstructionType.Stobj:
                case ILInstructionType.Stind:
                    MakeStoreObject(block, instruction.GetArgumentAs<Type>());
                    return true;

                default:
                    return false;
            }
        }
    }
}
